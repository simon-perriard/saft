use crate::analysis::specifications::std_ops_specs::std_ops_dispatch;

use crate::analysis::cost_analysis::{CalleeInfo, TransferFunction};

use self::frame_support_bounded_vec_specs::frame_support_bounded_vec_dispatch;
use self::frame_support_traits_specs::frame_support_traits_dispatch;
use self::frame_system_specs::frame_system_dispatch;
use self::sp_runtime_traits_specs::sp_runtime_traits_dispatch;
use self::std_cmp_specs::std_cmp_dispatch;
use self::std_convert_specs::std_convert_dispatch;
use self::std_default_specs::std_default_dispatch;
use self::std_slice_specs::std_slice_dispatch;

pub(crate) fn dispatch_to_specifications<'tcx>(
    transfer_function: &mut TransferFunction,
    callee_info: CalleeInfo<'tcx>,
) {
    let path = transfer_function
        .tcx
        .def_path_str(callee_info.callee_def_id);

    if path.starts_with("std::ops::") {
        std_ops_dispatch(transfer_function, callee_info);
    } else if path.starts_with("std::convert::") {
        std_convert_dispatch(transfer_function, callee_info);
    } else if path.starts_with("std::default::") {
        std_default_dispatch(transfer_function, callee_info);
    } else if path.starts_with("std::slice::") {
        std_slice_dispatch(transfer_function, callee_info);
    } else if path.starts_with("std::cmp::") {
        std_cmp_dispatch(transfer_function, callee_info);
    } else if path.starts_with("frame_system::") {
        frame_system_dispatch(transfer_function, callee_info);
    } else if path.starts_with("frame_support::traits::") {
        frame_support_traits_dispatch(transfer_function, callee_info);
    } else if path.starts_with("sp_runtime::traits::") {
        sp_runtime_traits_dispatch(transfer_function, callee_info);
    } else if path.starts_with("frame_support::BoundedVec::") {
        frame_support_bounded_vec_dispatch(transfer_function, callee_info);
    } else if path.starts_with("weights::WeightInfo::") {
        // Ignore
    } else {
        println!("{} --- {:?}", path, callee_info.func);
    }
}

pub(crate) mod std_ops_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn std_ops_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();
        match path {
            "std::ops::Try::branch" => {
                let ty_path = callee_info
                    .substs_ref
                    .type_at(0)
                    .sort_string(transfer_function.tcx)
                    .into_owned();
                match ty_path.as_str() {
                    "enum `std::result::Result`" => {
                        /* Account for function call /!\ INLINED                                        https://doc.rust-lang.org/nightly/std/result/enum.Result.html#method.branch
                            -> no cost
                        **/
                    }
                    _ => {
                        let ty_path = callee_info.substs_ref.type_at(0).to_string();
                        let normalized_fn_path = ty_path + "::branch()";
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(normalized_fn_path)));
                    }
                }
            }
            "std::ops::FromResidual::from_residual" => {
                let ty_path = callee_info.substs_ref.type_at(0).to_string();
                let ty_path = ty_path.as_str();
                match ty_path {
                    "std::result::Result<frame_support::dispatch::PostDispatchInfo, sp_runtime::DispatchErrorWithPostInfo<frame_support::dispatch::PostDispatchInfo>>"
                    if vec!["std::result::Result<std::convert::Infallible, frame_support::error::BadOrigin>", "std::result::Result<std::convert::Infallible, sp_runtime::DispatchError>"]
                        .contains(&callee_info.substs_ref.type_at(1).to_string().as_str())  => {

                        if callee_info.substs_ref.type_at(1).to_string().as_str() == "std::result::Result<std::convert::Infallible, frame_support::error::BadOrigin>" {
                            /* Account for function call /!\ INLINED +                                  https://doc.rust-lang.org/nightly/std/result/enum.Result.html#method.from_residual-2
                                DispatchErrorWithPostInfo::from(BadOrigin as Into<DispatchError>) +     https://docs.substrate.io/rustdocs/latest/sp_runtime/struct.DispatchErrorWithPostInfo.html#method.from
                                    BadOrigin::into(DispatchError) +                                    https://docs.substrate.io/rustdocs/latest/sp_runtime/traits/struct.BadOrigin.html#method.into
                                        DispatchError::From(BadOrigin)                                  https://docs.substrate.io/rustdocs/latest/sp_runtime/enum.DispatchError.html#method.from-2
                            */
                            transfer_function.domain_state.add_steps(Cost::Concrete(3));
                        } else {
                            /* Account for function call /!\ INLINED +                                  https://doc.rust-lang.org/nightly/std/result/enum.Result.html#method.from_residual-2
                                DispatchErrorWithPostInfo::from(DispatchErroras Into<DispatchError>) +  https://docs.substrate.io/rustdocs/latest/sp_runtime/struct.DispatchErrorWithPostInfo.html#method.from
                                    DispatchError::into(DispatchError) +                                https://docs.substrate.io/rustdocs/latest/frame_support/dispatch/enum.DispatchError.html#method.into
                                        DispatchError::From(DispatchError)                              https://docs.substrate.io/rustdocs/latest/frame_support/dispatch/enum.DispatchError.html#method.from-7
                            */
                            transfer_function.domain_state.add_steps(Cost::Concrete(3));
                        }
                    },
                    _ => {
                        let ty_path = callee_info.substs_ref.type_at(0).to_string();
                        let arg_ty_path = callee_info.substs_ref.type_at(1).to_string();
                        let normalized_fn_path = format!("{}::from_residual({})", ty_path, arg_ty_path);
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(normalized_fn_path)));
                    }
                }
            }
            "std::ops::Deref::deref" => {
                let ty_path = callee_info
                    .substs_ref
                    .type_at(0)
                    .sort_string(transfer_function.tcx)
                    .into_owned();

                match ty_path.as_str() {
                    "struct `frame_support::BoundedVec`" => {
                        // Account for function call                                                    https://docs.substrate.io/rustdocs/latest/frame_support/storage/bounded_vec/struct.BoundedVec.html#method.deref
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                    }
                    _ => {
                        let ty_path = callee_info.substs_ref.type_at(0).to_string();
                        let normalized_fn_path = ty_path + "::deref()";
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(normalized_fn_path)));
                    }
                }
            }
            "std::ops::Mul::mul" => {
                let mul_ty = transfer_function
                    .local_types
                    .borrow()
                    .get(callee_info.args[0].place().unwrap().local)
                    .unwrap()
                    .to_string();

                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!("{}::mul", mul_ty))));
            }
            _ => {
                unimplemented!("{} --- {:?}", path, callee_info.func);
            }
        }
    }
}

pub(crate) mod std_cmp_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn std_cmp_dispatch(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let func_name = path.split("::").last().unwrap();
        let ty = callee_info.substs_ref.type_at(0).to_string();
        transfer_function
            .domain_state
            .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                "{}::cmp::{}",
                ty, func_name
            ))));
    }
}

pub(crate) mod std_convert_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn std_convert_dispatch(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();
        match path {
            "std::convert::Into::into" => {
                let ty_path_from = callee_info.substs_ref.type_at(0).to_string();
                let ty_path_from = ty_path_from.as_str();

                let ty_path_into = callee_info.substs_ref.type_at(1).to_string();
                let ty_path_into = ty_path_into.as_str();

                match (ty_path_from, ty_path_into) {
                    ("std::option::Option<u64>", "frame_support::dispatch::PostDispatchInfo") => {
                        /* Account for function call +                                              https://doc.rust-lang.org/std/option/enum.Option.html#method.into
                            PostDispatchInfo::from(Option<u64>)                                     https://docs.substrate.io/rustdocs/latest/frame_support/weights/struct.PostDispatchInfo.html#method.from-2
                                Pays::default                                                       https://docs.substrate.io/rustdocs/latest/frame_support/weights/enum.Pays.html#method.default
                        **/
                        transfer_function.domain_state.add_steps(Cost::Concrete(3));
                    }
                    _ => {
                        let normalized_fn_path =
                            format!("{}::into({})", ty_path_from, ty_path_into);
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(normalized_fn_path)));
                    }
                }
            }
            "std::convert::From::from" => {
                let ty_path_from = callee_info.substs_ref.type_at(1).to_string();
                let ty_path_from = ty_path_from.as_str();

                let ty_path_into = callee_info.substs_ref.type_at(0).to_string();
                let ty_path_into = ty_path_into.as_str();

                match (ty_path_from, ty_path_into) {
                    ("pallet::Error<T>", "sp_runtime::DispatchError") => {
                        // call "index"
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(
                                "PalletInfo::index()".to_string(),
                            )));
                        // call "expect" https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.expect /!\ INLINED
                        //      call to "expect_failed", if so, calls panic!s
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                        // call "from"
                        /* Code generated by the pallet macros
                            impl<T: Config> From<Error<T>> for frame_support::sp_runtime::DispatchError {
                                fn from(err: Error<T>) -> Self {
                                    let index = < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: index :: < Pallet < T > > () . expect ("Every active module has an index in the runtime; qed") as u8 ;
                                    frame_support::sp_runtime::DispatchError::Module(
                                        frame_support::sp_runtime::ModuleError {
                                            index,
                                            error: err.as_u8(),
                                            message: Some(err.as_str()),
                                        },
                                    )
                                }
                            }
                        */
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));

                        // call "as_u8" for pallet::Error
                        // it is a simple pattern matching, mapping to a u8
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));

                        // call "as_str" for pallet::Error
                        // it is a simple pattern matching, mapping to a string
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                    }
                    _ => {
                        let normalized_fn_path =
                            format!("{}::from({})", ty_path_into, ty_path_from);
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(normalized_fn_path)));
                    }
                }
            }
            _ => {
                unimplemented!("{} --- {:?}", path, callee_info.func);
            }
        }
    }
}

pub(crate) mod std_default_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn std_default_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();
        match path {
            "std::default::Default::default" => {
                let ty_path = callee_info.substs_ref.type_at(0).to_string();

                match ty_path.as_str() {
                    "types::IdentityFields" => {
                        /* Account for function call /!\ INLINED +                                  https://docs.substrate.io/rustdocs/latest/pallet_identity/struct.IdentityFields.html#method.default
                            BitFlags::default /!\ INLINED                                           https://docs.rs/enumflags2/latest/enumflags2/struct.BitFlags.html#method.default
                            -> no cost
                        **/
                    }
                    _ => {
                        let ty_path = callee_info.substs_ref.type_at(0).to_string();
                        let normalized_fn_path = ty_path + "::default()";
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(normalized_fn_path)));
                    }
                }
            }
            _ => {
                unimplemented!("{} --- {:?}", path, callee_info.func);
            }
        }
    }
}

pub(crate) mod std_slice_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn std_slice_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();
        match path {
            "std::slice::SliceIndex::get" => {
                // match on self of get(self, slice) https://doc.rust-lang.org/nightly/std/slice/trait.SliceIndex.html#tymethod.get
                let self_ty = transfer_function
                    .local_types
                    .borrow()
                    .get(callee_info.args[0].place().unwrap().local)
                    .unwrap()
                    .to_string();
                match self_ty.as_str() {
                    "usize" => {
                        // call to "get" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.get-5
                        //      call to "len" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.len
                        //      comparison
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                        //      call to "get_unchecked_mut" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.get_unchecked-5
                        //          call to "len" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.len
                        //          comparison
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                        //      call as_ptr /!\ INLINED
                        //          all underlying calls are inlined
                        //      call add /!\ INLINED
                        //          all underlying calls are inlined until "intrisics::offset", could not go further
                        //              len may be at most substs_ref[1]::get
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                                "intrisics::offset({}::get())",
                                callee_info.substs_ref.type_at(1)
                            ))));
                    }
                    _ => unimplemented!("{}", self_ty),
                }
            }
            _ => unimplemented!(
                "{} --- {:?} --- {:?}",
                path,
                callee_info.func,
                callee_info.substs_ref,
            ),
        }
    }
}

pub(crate) mod frame_system_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn frame_system_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();
        match path {
            "frame_system::ensure_signed" => {
                // call "ensure_signed" https://docs.substrate.io/rustdocs/latest/frame_system/fn.ensure_signed.html
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "ensure_signed({})",
                        transfer_function
                            .local_types
                            .borrow()
                            .get(callee_info.args[0].place().unwrap().local)
                            .unwrap()
                            .to_string()
                    ))))
            }
            _ => unimplemented!("{}", path),
        }
    }
}

pub(crate) mod frame_support_traits_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    pub(crate) fn frame_support_traits_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();
        match path {
            "frame_support::traits::EnsureOrigin::ensure_origin" => {
                /* Account for function call +                                                         https://docs.substrate.io/rustdocs/latest/frame_support/traits/trait.EnsureOrigin.html#method.ensure_origin
                    try_origin
                */
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                account_for_try_origin(transfer_function, callee_info);
            }
            "frame_support::traits::EnsureOrigin::try_origin" => {
                account_for_try_origin(transfer_function, callee_info);
            }
            "frame_support::traits::Get::get" => {
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "{}::get()",
                        callee_info.substs_ref.type_at(0).to_string()
                    ))));
            }
            _ => {
                unimplemented!("{} --- {:?}", path, callee_info.func);
            }
        }
    }

    fn account_for_try_origin<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let ty_high_order = callee_info.substs_ref.type_at(0).to_string();
        let ty_arg = transfer_function.local_types.borrow()
            [callee_info.args[0].place().unwrap().local]
            .to_string();

        transfer_function
            .domain_state
            .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                "{}::try_origin({})",
                ty_high_order, ty_arg
            ))));
    }
}

pub(crate) mod sp_runtime_traits_specs {
    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };

    use rustc_middle::ty::TyKind;

    pub(crate) fn sp_runtime_traits_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();

        match path {
            "sp_runtime::traits::Zero::zero" => {
                let ty_path = callee_info.substs_ref.type_at(0).to_string();
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "{}::zero()",
                        ty_path
                    ))));
            }
            "sp_runtime::traits::StaticLookup::lookup" => {
                let ty_path = callee_info.substs_ref.type_at(0).to_string();
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "lookup({})",
                        ty_path
                    ))));

                // get the destination type to know what type is read from storage
                // return type is Result<read_type, error_type>
                let res = transfer_function
                    .local_types
                    .borrow()
                    .get(callee_info.destination.unwrap().0.local)
                    .unwrap()
                    .kind();
                let read_type = match res {
                    TyKind::Adt(_, substs_ref) => substs_ref.type_at(0),
                    _ => unreachable!(),
                };
                transfer_function
                    .domain_state
                    .add_reads(Cost::Symbolic(Symbolic::SizeOf(read_type.to_string())));
            }
            _ => {
                unimplemented!(
                    "{} --- {:?} --- {:?}",
                    path,
                    callee_info.func,
                    callee_info.substs_ref,
                );
            }
        }
    }
}

pub(crate) mod frame_support_bounded_vec_specs {

    use rustc_index::vec::IndexVec;

    use crate::analysis::{
        cost_analysis::{CalleeInfo, TransferFunction},
        cost_language::{Cost, Symbolic},
    };
    use rustc_middle::ty::TyKind;

    pub(crate) fn frame_support_bounded_vec_dispatch<'tcx>(
        transfer_function: &mut TransferFunction,
        callee_info: CalleeInfo<'tcx>,
    ) {
        let path = transfer_function
            .tcx
            .def_path_str(callee_info.callee_def_id);
        let path = path.as_str();

        match path {
            "frame_support::BoundedVec::<T, S>::try_push" => {
                // call try_push                                                    https://docs.substrate.io/rustdocs/latest/frame_support/storage/bounded_vec/struct.BoundedVec.html#method.try_push
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //      call to len() /!\ INLINED
                //      call to Self::bound
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //          call to substs_ref[1]::get
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "{}::get()",
                        callee_info.substs_ref.type_at(1)
                    ))));
                //      comparison
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //      call to push /!\ INLINED
                //          call to self.buf.capacity /!\ INLINED
                //              call to size_of /!\ INLINED
                //              comparison
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //      comparison
                transfer_function.domain_state.add_steps(Cost::Concrete(1));

                //      call reserve_for_push
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //          call grow_amortized(additional=1)
                //TODO: upperbound by MAX SIZE of vector
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(
                        "grow_amortized".to_string(),
                    )));
                //          call handle_reserve /!\ INLINED
                //      call as_mut_ptr /!\ INLINED
                //          all underlying calls are inlined
                //      call add /!\ INLINED
                //          all underlying calls are inlined until "intrisics::offset", could not go further
                //              len may be at most substs_ref[1]::get
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "intrisics::offset({}::get())",
                        callee_info.substs_ref.type_at(1)
                    ))));
                //      call write /!\ INLINED
                transfer_function
                    .domain_state
                    .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                        "ptr::write({})",
                        callee_info.substs_ref.type_at(0)
                    ))));
                //      addition
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
            }
            "frame_support::BoundedVec::<T, S>::get_mut" => {
                // call "get_mut"   https://docs.substrate.io/rustdocs/latest/frame_support/storage/bounded_vec/struct.BoundedVec.html#method.get_mut
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //      call "Vec::get_mut" https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.get_mut /!\ INLINED
                //      which resolves to "slice::get_mut" https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.get_mut
                //      the upcoming call depends on the Index type
                let index_type = callee_info
                    .substs_ref
                    .last()
                    .unwrap()
                    .expect_ty()
                    .to_string();

                match index_type.as_str() {
                    "usize" => {
                        // https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.get_mut-5
                        //      call to "len" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.len
                        //      comparison
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                        //      call to "get_unchecked_mut" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.get_unchecked_mut-5
                        //          call to "len" /!\ INLINED https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.len
                        //          comparison
                        transfer_function.domain_state.add_steps(Cost::Concrete(1));
                        //      call as_mut_ptr /!\ INLINED
                        //          all underlying calls are inlined
                        //      call add /!\ INLINED
                        //          all underlying calls are inlined until "intrisics::offset", could not go further
                        //              len may be at most substs_ref[1]::get
                        transfer_function
                            .domain_state
                            .add_steps(Cost::Symbolic(Symbolic::TimeOf(format!(
                                "intrisics::offset({}::get())",
                                callee_info.substs_ref.type_at(1)
                            ))));
                    }
                    _ => {
                        todo!("get_mut for {:?}", index_type)
                    }
                }
            }
            "frame_support::BoundedVec::<T, S>::retain" => {
                /*// call "retain" https://docs.substrate.io/rustdocs/latest/frame_support/storage/bounded_vec/struct.BoundedVec.html#method.retain
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //      call "retain" https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.retain
                transfer_function.domain_state.add_steps(Cost::Concrete(1));
                //          call "retain_mut" https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.retain_mut
                //              get cost of running the closure
                let closure_def_id = match transfer_function
                .local_types
                .borrow()
                .get(callee_info.args[1].place().unwrap().local)
                .unwrap()
                .kind() {
                    TyKind::Closure(def_id, _) => *def_id,
                    _ => unreachable!("Argument can only be a TyKind::Closure")
                };

                let key = (closure_def_id, IndexVec::new());

                let closure_cost = if transfer_function.summaries.borrow().contains_key(&key) {
                    let summaries = transfer_function.summaries.borrow();
                    let summary = summaries.get(&key).unwrap();

                    match summary {
                        Some(cost) => cost,
                        None => unreachable!("Cannot have recursive closures"),
                    }

                } else {
                    unreachable!("Closure must have been analyzed."); 
                };

                transfer_function.domain_state.inter_join(closure_cost.)
                
                panic!();*/
            }
            _ => println!("{}", path),
        }
    }
}

pub(crate) mod storage_actions_specs {

    use crate::analysis::{
        cost_language::{Cost, HasSize, Symbolic},
        pallet::{Field, StorageKind},
    };
    use rustc_middle::ty::{TyCtxt, TyKind};

    // https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageValue.html
    // https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageMap.html

    #[derive(Debug)]
    pub(crate) struct AccessCost {
        pub reads: Cost,
        pub writes: Cost,
        pub steps: Cost,
    }

    impl AccessCost {
        pub fn new(reads: Cost, writes: Cost, steps: Cost) -> Self {
            AccessCost {
                reads,
                writes,
                steps,
            }
        }
    }

    pub(crate) trait HasAccessCost {
        fn get_access_cost(&self, tcx: TyCtxt, action: &str) -> Option<AccessCost>;
    }

    impl HasAccessCost for Field {
        fn get_access_cost(&self, tcx: TyCtxt, action: &str) -> Option<AccessCost> {
            match &self.kind {
                StorageKind::StorageValue { .. } => {
                    StorageValueActions::get_access_cost(tcx, self, action)
                }
                StorageKind::StorageMap { .. } => {
                    StorageMapActions::get_access_cost(tcx, self, action)
                }
                StorageKind::StorageDoubleMap { .. } => {
                    StorageDoubleMapActions::get_access_cost(tcx, self, action)
                }
                StorageKind::StorageNMap { .. } => todo!(),
                StorageKind::CountedStorageMap { .. } => todo!(),
            }
        }
    }

    pub(crate) enum StorageValueActions {
        Append,
        DecodeLen,
        Exists,
        Get,
        Kill,
        Mutate,
        Put,
        Set,
        Take,
        Translate,
        TryAppend,
        TryGet,
        TryMutate,
    }

    impl StorageValueActions {
        fn is_storage_value_action(action: &str) -> bool {
            StorageValueActions::storage_value_actions().contains(&action.to_owned())
        }

        fn storage_value_actions() -> Vec<String> {
            let storage_value_actions = vec![
                "append",
                "decode_len",
                "exists",
                "get",
                "kill",
                "mutate",
                "put",
                "set",
                "take",
                "translate",
                "try_append",
                "try_get",
                "try_mutate",
            ];

            storage_value_actions
                .iter()
                .map(|action| String::from(*action))
                .collect()
        }

        fn from(action: &str) -> StorageValueActions {
            match action {
                "append" => StorageValueActions::Append,
                "decode_len" => StorageValueActions::DecodeLen,
                "exists" => StorageValueActions::Exists,
                "get" => StorageValueActions::Get,
                "kill" => StorageValueActions::Kill,
                "mutate" => StorageValueActions::Mutate,
                "put" => StorageValueActions::Put,
                "set" => StorageValueActions::Set,
                "take" => StorageValueActions::Take,
                "translate" => StorageValueActions::Translate,
                "try_append" => StorageValueActions::TryAppend,
                "try_get" => StorageValueActions::TryGet,
                "try_mutate" => StorageValueActions::TryMutate,
                _ => panic!("Invalid StorageValue action"),
            }
        }

        pub fn get_access_cost(tcx: TyCtxt, field: &Field, action: &str) -> Option<AccessCost> {
            let action_short = action.split("::").last().unwrap();

            if !Self::is_storage_value_action(action_short) {
                None
            } else {
                let substs_ref =
                    if let TyKind::Adt(_, substs_ref) = tcx.type_of(field.def_id).kind() {
                        substs_ref
                    } else {
                        unreachable!()
                    };

                let mut steps = Cost::default();
                let mut reads = Cost::default();
                let mut writes = Cost::default();

                match Self::from(action_short) {
                    StorageValueActions::Append => todo!(),
                    StorageValueActions::DecodeLen => todo!(),
                    StorageValueActions::Exists => todo!(),
                    StorageValueActions::Get => {
                        steps = steps + Cost::Concrete(1);
                        // compute storage key
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_value_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        // get data from storage
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "sp_io::storage::get({:?})",
                                substs_ref[1]
                            )));
                        reads = reads + field.get_size(&tcx);
                        // decode the whole data
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "decode({:?})",
                                substs_ref[1]
                            )));
                        // from_optional_to_query_value
                        steps = steps + Cost::Concrete(1);
                    }
                    StorageValueActions::Kill => {
                        // call "kill"
                        steps = steps + Cost::Concrete(1);
                        // compute storage key
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_value_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf("unhashed::kill()".to_string()));
                        // Write None to database
                        writes = writes + Cost::Concrete(1);
                    }
                    StorageValueActions::Mutate => {
                        // call "try_mutate"
                        let try_mutate_cost = Self::get_access_cost(tcx, field, "try_mutate")?;

                        reads = reads + try_mutate_cost.reads;
                        writes = writes + try_mutate_cost.writes;
                        steps = steps + try_mutate_cost.steps;

                        // call to "expect" https://doc.rust-lang.org/nightly/core/result/enum.Result.html#method.expect /!\ INLINED
                        //      call to "unwrap_failed", if so, calls panic!s
                    }
                    StorageValueActions::Put => {
                        // call "put"
                        steps = steps + Cost::Concrete(1);
                        // compute storage key
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_value_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        // call unhashed::put
                        steps = steps + Cost::Concrete(1);
                        // encode the value
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "encode({:?})",
                                substs_ref[1]
                            )));
                        // write data to storage
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "sp_io::storage::set({:?})",
                                substs_ref[1]
                            )));
                        writes = writes + field.get_size(&tcx);
                    }
                    StorageValueActions::Set => todo!(),
                    StorageValueActions::Take => todo!(),
                    StorageValueActions::Translate => todo!(),
                    StorageValueActions::TryAppend => todo!(),
                    StorageValueActions::TryGet => todo!(),
                    StorageValueActions::TryMutate => {
                        // call try_mutate https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageValue.html#method.try_mutate
                        steps = steps + Cost::Concrete(1);
                        // call get https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/value.rs#63
                        let get_access_cost = Self::get_access_cost(tcx, field, "get")?;
                        reads = reads + get_access_cost.reads;
                        writes = writes + get_access_cost.writes;
                        steps = steps + get_access_cost.steps;
                        // apply closure (done in analyze_storage_access)
                        // "if" branch is more costly, account for call to is_ok()
                        steps = steps + Cost::Concrete(1);
                        // call from_query_to_optional_value
                        steps = steps + Cost::Concrete(1);

                        // "put" has greater cost than "kill"
                        let put_access_cost = Self::get_access_cost(tcx, field, "put")?;
                        reads = reads + put_access_cost.reads;
                        writes = writes + put_access_cost.writes;
                        steps = steps + put_access_cost.steps;
                    }
                };
                Some(AccessCost::new(reads, writes, steps))
            }
        }
    }

    pub(crate) enum StorageMapActions {
        Append,
        ContainsKey,
        DecodeLen,
        Drain,
        Get,
        Insert,
        Iter,
        IterFrom,
        IterKeys,
        IterKeysFrom,
        IterValues,
        MigrateKey,
        Mutate,
        MutateExists,
        Remove,
        RemoveAll,
        Swap,
        Take,
        Translate,
        TranslateValues,
        TryAppend,
        TryGet,
        TryMutate,
        TryMutateExists,
    }

    impl StorageMapActions {
        fn is_storage_map_action(action: &str) -> bool {
            StorageMapActions::storage_map_actions().contains(&action.to_owned())
        }

        fn storage_map_actions() -> Vec<String> {
            let storage_map_actions = vec![
                "append",
                "contains_key",
                "decode_len",
                "drain",
                "get",
                "insert",
                "iter",
                "iter_from",
                "iter_keys",
                "iter_keys_from",
                "iter_values",
                "migrate_key",
                "mutate",
                "mutate_exists",
                "remove",
                "remove_all",
                "swap",
                "take",
                "translate",
                "translate_values",
                "try_append",
                "try_get",
                "try_mutate",
                "try_mutate_exists",
            ];

            storage_map_actions
                .iter()
                .map(|action| String::from(*action))
                .collect()
        }

        fn from(action: &str) -> StorageMapActions {
            match action {
                "append" => StorageMapActions::Append,
                "contains_key" => StorageMapActions::ContainsKey,
                "decode_len" => StorageMapActions::DecodeLen,
                "drain" => StorageMapActions::Drain,
                "get" => StorageMapActions::Get,
                "insert" => StorageMapActions::Insert,
                "iter" => StorageMapActions::Iter,
                "iter_from" => StorageMapActions::IterFrom,
                "iter_keys" => StorageMapActions::IterKeys,
                "iter_keys_from" => StorageMapActions::IterKeysFrom,
                "iter_values" => StorageMapActions::IterValues,
                "migrate_key" => StorageMapActions::MigrateKey,
                "mutate" => StorageMapActions::Mutate,
                "mutate_exists" => StorageMapActions::MutateExists,
                "remove" => StorageMapActions::Remove,
                "remove_all" => StorageMapActions::RemoveAll,
                "swap" => StorageMapActions::Swap,
                "take" => StorageMapActions::Take,
                "translate" => StorageMapActions::Translate,
                "translate_values" => StorageMapActions::TranslateValues,
                "try_append" => StorageMapActions::TryAppend,
                "try_get" => StorageMapActions::TryGet,
                "try_mutate" => StorageMapActions::TryMutate,
                "try_mutate_exists" => StorageMapActions::TryMutateExists,
                _ => panic!("Invalid StorageMap action"),
            }
        }

        pub fn get_access_cost(tcx: TyCtxt, field: &Field, action: &str) -> Option<AccessCost> {
            let action_short = action.split("::").last().unwrap();

            if !Self::is_storage_map_action(action_short) {
                None
            } else {
                let substs_ref =
                    if let TyKind::Adt(_, substs_ref) = tcx.type_of(field.def_id).kind() {
                        substs_ref
                    } else {
                        unreachable!()
                    };

                let mut steps = Cost::default();
                let mut reads = Cost::default();
                let mut writes = Cost::default();

                match Self::from(action_short) {
                    StorageMapActions::Append => todo!(),
                    StorageMapActions::ContainsKey => {
                        // call "get" https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/map.rs.html#236
                        steps = steps + Cost::Concrete(1);
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_map_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::exists()")));
                        reads = reads + field.get_size(&tcx);
                    }
                    StorageMapActions::DecodeLen => todo!(),
                    StorageMapActions::Drain => todo!(),
                    StorageMapActions::Get => {
                        // call "get" https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/map.rs.html#240
                        steps = steps + Cost::Concrete(1);
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_map_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::get()")));
                        reads = reads + field.get_size(&tcx);
                    }
                    StorageMapActions::Insert => {
                        // call "insert" https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/map.rs.html#248
                        steps = steps + Cost::Concrete(1);
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_map_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::put()")));
                        writes = writes + field.get_size(&tcx);
                    }
                    StorageMapActions::Iter => todo!(),
                    StorageMapActions::IterFrom => todo!(),
                    StorageMapActions::IterKeys => todo!(),
                    StorageMapActions::IterKeysFrom => todo!(),
                    StorageMapActions::IterValues => todo!(),
                    StorageMapActions::MigrateKey => todo!(),
                    StorageMapActions::Mutate => {
                        // call "try_mutate"
                        let try_mutate_cost = Self::get_access_cost(tcx, field, "try_mutate")?;

                        reads = reads + try_mutate_cost.reads;
                        writes = writes + try_mutate_cost.writes;
                        steps = steps + try_mutate_cost.steps;

                        // call to "expect" https://doc.rust-lang.org/nightly/core/result/enum.Result.html#method.expect /!\ INLINED
                        //      call to "unwrap_failed", if so, calls panic!s
                    }
                    StorageMapActions::MutateExists => todo!(),
                    StorageMapActions::Remove => {
                        // call "remove" https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/map.rs.html#248
                        steps = steps + Cost::Concrete(1);
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_map_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::kill()")));
                        writes = writes + Cost::Concrete(1);
                    }
                    StorageMapActions::RemoveAll => todo!(),
                    StorageMapActions::Swap => todo!(),
                    StorageMapActions::Take => {
                        // call "take" https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/map.rs.html#303
                        steps = steps + Cost::Concrete(1);
                        // compute storage key
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_map_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        //      call unhashed::take
                        steps = steps + Cost::Concrete(1);
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::get()")));
                        reads = reads + field.get_size(&tcx);

                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::kill()")));
                        // Write "None" to storage
                        writes = writes + Cost::Concrete(1);
                    }
                    StorageMapActions::Translate => todo!(),
                    StorageMapActions::TranslateValues => todo!(),
                    StorageMapActions::TryAppend => todo!(),
                    StorageMapActions::TryGet => todo!(),
                    StorageMapActions::TryMutate => {
                        // call try_mutate https://docs.substrate.io/rustdocs/latest/src/frame_support/storage/generator/map.rs.html#286
                        steps = steps + Cost::Concrete(1);
                        // compute storage key
                        steps = steps
                            + Cost::Symbolic(Symbolic::TimeOf(format!(
                                "{}::storage_map_final_key()",
                                tcx.def_path_str(field.def_id)
                            )));
                        // call from_query_to_optional_value
                        steps = steps + Cost::Concrete(1);
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::get()")));
                        reads = reads + field.get_size(&tcx);
                        // apply closure (done in analyze_storage_access)
                        // "if" branch is more costly, account for call to is_ok()
                        steps = steps + Cost::Concrete(1);
                        // call from_query_to_optional_value
                        steps = steps + Cost::Concrete(1);

                        // "put" has greater cost than "kill"
                        steps =
                            steps + Cost::Symbolic(Symbolic::TimeOf(format!("unhashed::put()")));
                        writes = writes
                    }
                    StorageMapActions::TryMutateExists => todo!(),
                };
                Some(AccessCost::new(reads, writes, steps))
            }
        }
    }

    pub(crate) enum StorageDoubleMapActions {
        Append,
        ContainsKey,
        DecodeLen,
        Drain,
        DrainPrefix,
        Get,
        Insert,
        Iter,
        IterFrom,
        IterKeyPrefix,
        IterKeyPrefixFrom,
        IterKeys,
        IterKeysFrom,
        IterPrefix,
        IterPrefixFrom,
        IterPrefixValues,
        IterValues,
        MigrateKeys,
        Mutate,
        MutateExists,
        Remove,
        RemoveAll,
        RemovePrefix,
        Swap,
        Take,
        Translate,
        TranslateValues,
        TryAppend,
        TryGet,
        TryMutate,
        TryMutateExists,
    }

    impl StorageDoubleMapActions {
        fn is_storage_map_action(action: &str) -> bool {
            StorageDoubleMapActions::storage_double_map_actions().contains(&action.to_owned())
        }

        fn storage_double_map_actions() -> Vec<String> {
            let storage_double_map_actions = vec![
                "append",
                "contains_key",
                "decode_len",
                "drain",
                "drain_prefix",
                "get",
                "insert",
                "iter",
                "iter_from",
                "iter_key_prefix",
                "iter_key_prefix_from",
                "iter_keys",
                "iter_keys_from",
                "iter_prefix",
                "iter_prefix_from",
                "iter_prefix_values",
                "iter_values",
                "migrate_keys",
                "mutate",
                "mutate_exists",
                "remove",
                "remove_all",
                "remove_prefix",
                "swap",
                "take",
                "translate",
                "translate_values",
                "try_append",
                "try_get",
                "try_mutate",
                "try_mutate_exists",
            ];

            storage_double_map_actions
                .iter()
                .map(|action| String::from(*action))
                .collect()
        }

        fn from(action: &str) -> StorageDoubleMapActions {
            match action {
                "append" => StorageDoubleMapActions::Append,
                "contains_key" => StorageDoubleMapActions::ContainsKey,
                "decode_len" => StorageDoubleMapActions::DecodeLen,
                "drain" => StorageDoubleMapActions::Drain,
                "drain_prefix" => StorageDoubleMapActions::DrainPrefix,
                "get" => StorageDoubleMapActions::Get,
                "insert" => StorageDoubleMapActions::Insert,
                "iter" => StorageDoubleMapActions::Iter,
                "iter_from" => StorageDoubleMapActions::IterFrom,
                "iter_key_prefix" => StorageDoubleMapActions::IterKeyPrefix,
                "iter_key_prefix_from" => StorageDoubleMapActions::IterKeyPrefixFrom,
                "iter_keys" => StorageDoubleMapActions::IterKeys,
                "iter_keys_from" => StorageDoubleMapActions::IterKeysFrom,
                "iter_prefix" => StorageDoubleMapActions::IterPrefix,
                "iter_prefix_from" => StorageDoubleMapActions::IterPrefixFrom,
                "iter_prefix_values" => StorageDoubleMapActions::IterPrefixValues,
                "iter_values" => StorageDoubleMapActions::IterValues,
                "migrate_keys" => StorageDoubleMapActions::MigrateKeys,
                "mutate" => StorageDoubleMapActions::Mutate,
                "mutate_exists" => StorageDoubleMapActions::MutateExists,
                "remove" => StorageDoubleMapActions::Remove,
                "remove_all" => StorageDoubleMapActions::RemoveAll,
                "remove_prefix" => StorageDoubleMapActions::RemovePrefix,
                "swap" => StorageDoubleMapActions::Swap,
                "take" => StorageDoubleMapActions::Take,
                "translate" => StorageDoubleMapActions::Translate,
                "translate_values" => StorageDoubleMapActions::TranslateValues,
                "try_append" => StorageDoubleMapActions::TryAppend,
                "try_get" => StorageDoubleMapActions::TryGet,
                "try_mutate" => StorageDoubleMapActions::TryMutate,
                "try_mutate_exists" => StorageDoubleMapActions::TryMutateExists,
                _ => panic!("Invalid StorageDoubleMap action"),
            }
        }

        pub fn get_access_cost(tcx: TyCtxt, field: &Field, action: &str) -> Option<AccessCost> {
            let action_short = action.split("::").last().unwrap();

            if !Self::is_storage_map_action(action_short) {
                None
            } else {
                let _substs_ref =
                    if let TyKind::Adt(_, substs_ref) = tcx.type_of(field.def_id).kind() {
                        substs_ref
                    } else {
                        unreachable!()
                    };

                let mut _steps = Cost::default();
                let mut _reads = Cost::default();
                let mut _writes = Cost::default();

                match Self::from(action_short) {
                    StorageDoubleMapActions::Append => todo!(),
                    StorageDoubleMapActions::ContainsKey => todo!(),
                    StorageDoubleMapActions::DecodeLen => todo!(),
                    StorageDoubleMapActions::Drain => todo!(),
                    StorageDoubleMapActions::DrainPrefix => todo!(),
                    StorageDoubleMapActions::Get => todo!(),
                    StorageDoubleMapActions::Insert => todo!(),
                    StorageDoubleMapActions::Iter => todo!(),
                    StorageDoubleMapActions::IterFrom => todo!(),
                    StorageDoubleMapActions::IterKeyPrefix => todo!(),
                    StorageDoubleMapActions::IterKeyPrefixFrom => todo!(),
                    StorageDoubleMapActions::IterKeys => todo!(),
                    StorageDoubleMapActions::IterKeysFrom => todo!(),
                    StorageDoubleMapActions::IterPrefix => todo!(),
                    StorageDoubleMapActions::IterPrefixFrom => todo!(),
                    StorageDoubleMapActions::IterPrefixValues => todo!(),
                    StorageDoubleMapActions::IterValues => todo!(),
                    StorageDoubleMapActions::MigrateKeys => todo!(),
                    StorageDoubleMapActions::Mutate => todo!(),
                    StorageDoubleMapActions::MutateExists => todo!(),
                    StorageDoubleMapActions::Remove => todo!(),
                    StorageDoubleMapActions::RemoveAll => todo!(),
                    StorageDoubleMapActions::RemovePrefix => todo!(),
                    StorageDoubleMapActions::Swap => todo!(),
                    StorageDoubleMapActions::Take => todo!(),
                    StorageDoubleMapActions::Translate => todo!(),
                    StorageDoubleMapActions::TranslateValues => todo!(),
                    StorageDoubleMapActions::TryAppend => todo!(),
                    StorageDoubleMapActions::TryGet => todo!(),
                    StorageDoubleMapActions::TryMutate => todo!(),
                    StorageDoubleMapActions::TryMutateExists => todo!(),
                };
                Some(AccessCost::new(_reads, _writes, _steps))
            }
        }
    }
}
